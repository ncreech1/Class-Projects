<title>SRM 728, D1, 250-Pointer (Halving)</title>
<h3>SRM 728, D1, 250-Pointer (Halving)</h3>
<h3>James S. Plank</h3>
Tue Nov 12 17:30:55 EST 2019
<hr>

<UL>
<LI><a href=https://community.topcoder.com/stat?c=problem_statement&pm=14807&rd=17064>Problem Statement</a>.
<LI> <a href=main.cpp>A <b>main()</b> with the examples compiled in.</a>
<LI> <a href=Halving.cpp>A skeleton that compiles with <b>main.cpp</b>.</a>
<p>
<LI> <b>Problem Given in Topcoder</b>: January, 2018
<LI> <b>Competitors who opened the problem</b>: 226
<LI> <b>Competitors who submitted a solution</b>: 209
<LI> <b>Number of correct solutions</b>: 164
<LI> <b>Accuracy (percentage correct vs those who opened)</b>: 72.6%
<LI> <b>Average Correct Time</b>: 20 minutes, 29 seconds.
</UL>

<hr>
<h3>In case Topcoder's servers are down</h3>

Here is a summary of the problem:

<UL>
<LI> You are given a collection of sticks with integer lengths between 1 and 10<sup<9></sup>.
<LI> Your goal is to break each stick, potentially zero times or potentially multiple times, 
     so that each stick ends up being the same length.
<LI> When you break a stick whose length is even, you get two sticks that are the same length.
     Keep one and discard the other.
<LI> When you break a stick whose length is odd, you get two sticks whose lengths differ by one.
     Keep one and discard the other.
<LI> Return the minimum number of total breaks that it takes to make each stick the same length.
<LI> The topcoder constraints has the number of sticks between 2 and 50.  I'm going to bump
     that up to 10,000.
</UL>

<hr>
<h3> Examples</h3>
<UL>
<LI> Example 0: { 11, 4 }.  Answer = 3 (Break 11 to 5, break 5 to 2, break 4 to 2)
<LI> Example 1: { 1000000000, 1000000000, 1000000000, 1000000000 }.  Answer = 0 (they are all the same size already)
<LI> Example 2: { 1, 2, 3, 4, 5, 6 }.  Answer = 10
<LI> Example 3: { 13, 13, 7, 11, 13, 11 }.  Answer = 11
<LI> Example 4: { 1, 1 }.  Answer = 0
</UL>

The driver in <b>main.cpp</b> has the examples compiled in, and if you enter "-" as a 
command line argument, you can read the values of the stick lengths on standard input.
<hr>
<h3>Testing yourself</h3>

Like the <a href=../../2010/Cryptography/index.html>Cryptography Problem</a>,
I have a shell script <b>tests.sh</b>, that you can use to test your program.  When you
run <b>tests.sh</b>, your answer should be identical to
<b><a href=answers.txt>answers.txt</a></b>.  Mine runs in about 2.5 seconds.
  
<hr>
<h3>Observation #1</h3>

Let's suppose we have one of these stick lengths. Call it <b>s</b>.
How many different lengths can it create?
I'm going to propose that the answer is under 100.  Think about it -- suppose that <b>s</b> is
roughly 2<sup>30</sup>.  
Then, when you halve it, you're going to get one or two numbers that are around
2<sup>29</sup>.  Suppose you now have two numbers from halving.  
When you halve them, you are only going to get two 
more distinct numbers.  There won't be more than a few distinct numbers for each round of halving.
For example:

<pre>

17 -> 8   -> 4   -> 2   -> 1   -> 1
   -> 9   -> 5   -> 3   -> 2
</pre>

You can get more than two per round, but it won't be by much.  To verify this, I wrote a quick
and dirty program that calculated how many lengths were generated by each <b>s</b> from 1 to
100,000.  The maximum value was 33.  That's a proof by cosmo, but I'll take it.
<p>
<h3>Strategy</h3>

Given this observation, your strategy should be straightforward:
<UL>
<LI> You are going to maintain two maps over the course of this program.  Both will have
     integer keys and vals.
<p>
<OL>
<LI> <i>canbreak</i> is keyed on stick lengths, and its val is the number of original sticks
     that can achieve the length by being broken 0 or more times.
<LI> <i>numbreaks</i> is also keyed on stick lengths, and its val contains the total number of
     breaks that it takes to break each stick to this length.
</OL>
<p>
<LI> Your answer is going to be the stick length where <i>canbreak</i> is equal to the
     number of sticks (meaning each stack may be broken to this length), and 
     <i>numbreaks</i> is minimized.
</UL>

Let's go over example zero to illustrate.  Sticks 11 and 4 may be broken as follows, 
which will generate the two maps <i>canbreak</i> and <i>numbreaks</i>:
<pre>
   Stick 11          Stick 4        canbreak       numbreaks
--------------    --------------    ---------      ---------
Length  Breaks    Length  Breaks    Key   Val      Key   Val 
  11       0         4       0       11     1       11     0
   6       1         2       1        6     1        6     1
   5       1         1       2        5     1        5     1
   3       2                          4     1        4     0
   2       2                          3     1        3     2
   1       3                          2     2        2     3
                                      1     2        1     5
</pre>

As you can see, the only stick lengths where <i>canbreak</i> is equal to the
number of sticks are 2 and 1.
Of these, the length with the minimum value of <i>numbreaks</i> is 2, whose val is 3, so the 
answer is 3.

<p>
<hr>
<h3>A recursive procedure to call on each stick length</h3>

I wrote a recursive procedure with the following prototype:

<p><center><table border=3 cellpadding=3><td><pre>
void all_breaks(int length, int breaks, map &lt;int, int&gt; &breakmap);
</pre></td></table></center><p>

For each stick length <b>len</b> in the input array, I called <b>all_breaks(len, 0, m)</b>,
where <b>m</b> was an empty map.  
<p>
What <b>all_breaks()</b> does is check to see if the length is in the map.  If it is,
and if its val is less than or equal to <b>breaks</b>, then <b>all_breaks()</b> returns.
That's its base case.
<p>
If it doesn't return, then it either adds <b>length</b> to the map with a val of <b>breaks</b>,
or it updates <b>length's</b> entry in the map to equal <b>breaks</b>.  Then, if <b>length</b>
is greater than one, it calls itself recursively on the two values that you get when you 
break <b>length</b>.  (You'll note that if <b>length</b> is even, it gets two of the same lengths,
but you don't really need to test for this -- if you make the same recursive call twice, it 
will return instantly on the second one, because the first one has put the length into the map.).
<p>
When <b>all_breaks(len, 0, m)</b> returns, the map <b>m</b> will contain all of the information
that you need to update <i>canbreak</i> and <i>numbreaks</i>.
<p>
If the recursion is confusing to you -- here's what happens when you call <b>all_breaks(11, 0, {})</b>:

<pre>
all_breaks(11, 0, {}) puts [11,0] into the map and then calls all_breaks recursively on 5 and 6.
  all_breaks(5, 1, {[11,0]}) puts [5,1] into the map and then calls all_breaks recursively on 2 and 3.
    all_breaks(2, 2, {[5,1],[11,0]}) puts [2,2] into the map and then calls all_breaks recursively on 1 and 1.
      all_breaks(1, 3, {[2,2],[5,1],[11,0]}) puts [1,3] into the map and returns.
      all_breaks(1, 3, {[1,3],[2,2],[5,1],[11,0]}) returns because 1 is in the map.
    all_breaks(2, 2, ..) returns
    all_breaks(3, 2, {[1,3],[2,2],[5,1],[11,0]}) puts [3,2] into the map and then calls all_breaks recursively on 2 and 1.
      all_breaks(2, 3, {[1,3],[2,2],[3,2],[5,1],[11,0]}) returns, because 2 is in the map with a smaller value.
      all_breaks(1, 3, {[1,3],[2,2],[3,2],[5,1],[11,0]}) returns, because 1 is in the map with the same value.
    all_breaks(3, 2, ..) returns
  all_breaks(5, 1, ..) returns
  all_breaks(6, 1, {[1,3],[2,2],[3,2],[5,1],[11,0]}) puts [6,1] into the map and then calls all_breaks recursively on 3 and 3.
    all_breaks(3, 2, {[1,3],[2,2],[3,2],[5,1],[6,1],[11,0]}) returns, because 3 is in the map with the same value.
    all_breaks(3, 2, {[1,3],[2,2],[3,2],[5,1],[6,1],[11,0]}) returns for ibid.
  all_breaks(6, 1, ..) returns
all_breaks(11, 0, ..) returns

The final map is {[1,3],[2,2],[3,2],[5,1],[6,1],[11,0]}.  You'll note how it matchs the "stick 11" table above.
</pre>

<hr>
<h3>Putting the pieces together</h3>

I would start by writing <b>all_breaks()</b> and testing it by printing it out -- you can see 
the resulting maps for 11 and 4 above.  For 1000000000, the map is in the file
<b><a href=big.txt>big.txt</a></b>.  You'll note that there are 50 elements in the map.
<p>
After you are sure you have written <b>all_breaks()</b> correctly, go ahead and finish the
program.

<hr>
<h3>Running time</h3>

Calculating this one's running time is a pain to do in detail.  However, with the maximum 
stick length capped at 10<sup></sup>, this means that the maximum size of <i>breakmap</i>
will be roughly 40.  That allows us to saly that <b>all_breaks()</b> will run in <i>O(1)</i>
time.  If the number of sticks is <i>n</i>, the size of <i>canbreak</i> and <i>minbreaks</i>
will be capped at <i>40n</i>, which is <i>O(n)</i>.  
<p>
This means that the running time is <i>n</i> times the sum of:
<UL>
<LI> Calling <b>all_breaks()</b>, which is <i>O(1)</i>.
<LI> Updating <i>canbreak</i> and <i>minbreaks</i> after calling <b>all_breaks()</b>.
     That is <i>O(log n)</i>.
</UL>
So this is <i>O(n log n)</i>.
